# Rusty Packaging Quirks

## Gotchas

- rustc will apparently cull unused files from compilation, so if you're trying to experiment quickly with what will compile deep in the bowels of a lib that aren't referenced from top level (including by mod declaration), the compiler will happily say success for things that should fail. At least in the context of a package containing a lib.rs and main.rs? Lovely.
- module lookup appears to be relative to entry points e.g. main.rs or lib.rs rather than project-wide, which is very silly and annoying. It means you can wind up in a weird case where moduleA depends on moduleB and both are declared somewhere, but if from some entry point perspective moduleA is declared and moduleB is not you'll get an error that just says "wtf is moduleB?". This also means you can't just refer to common package names or include dir shortcuts from anywhere in the project like a sane programming language, and instead need to refer to crate level from sibling/implementation perspectives, local declaration level from entry points, and package level (basically crate level but using the package name instead) from dependent perspectives. A+ design.

## Module Lookup

- When using the folder + folder_name.rs hack approach to IDing "folder modules", the folder name and folder_name.rs really do need to match or you wind up IDing the variant folder_name.rs as the module and the submodules under the actual folder name will not be found.
  - Also, the crate root level module lookup path does not work by folder name alone; it needs the folder_name.rs guy to ID the folder name as a module apparently, in which case you can refer to sibling modules from root down perspective without an additional mod keyword to bring the relevant module in scope.
  - Simply having the folder + folder_name.rs combo is not enough to ID it as a folder module; you also need somebody at the top level e.g. lib.rs or main.rs normally to declare the module with the mod keyword. Without that, using crate::folder_name will complain module folder_name cannot be found in crate root.

### Top level keyword crate lookup

- Modules will only be indexed relative to top level crate if they are declared somewhere, e.g. in entry points like lib.rs
  - I'm not 100% sure this is always true since the cube_tester was a rat's nest of crate::x sibling file references before I added a lib.rs for integration test purposes with top level module declarations, and it somehow still worked. Maybe having a lib.rs changes the rules? EDIT: I don't think so; probably we had module declarations inside main.rs before or something since you would need them someplace in order to actually use even top level sister files.
  - Also notable, if you have a path to a moduleA from an entry point e.g. main.rs that doesn't declare a given moduleC but moduleA depends on moduleC, then you'll get a compiler error even if moduleC is declared elsewhere e.g. in lib.rs. This can create quite confusing errors.
- Sibling modules/submodules cannot look each other up by module name directly per whatever module declarations have already happened at the top level e.g. lib.rs; they must fall back to the crate root and import the module via its full top-down path. I had assumed that saing `mod X;` inside a sibling module would be enough to get the compiler to do a fresh lookup from that perspective, but evidently not. Naturally the documentation does not touch upon this point and stops after the Hello World of lib design. I guess the guts of the lib could refer back to the lib API itself for sister calls, but that seems weird. EDIT: actually you can't really do that either because the lib.rs file does not become a module automatically, and you can't use the package name from inside its own guts as a reference point into the top level library API. You can make a module inside lib.rs called whatever e.g. lib and then refer to him via crate lookup, but he will not automagically know anything about the other modules declared in lib.rs unless they're submodules of lib. Declaring the other modules inside the lib module also doesn't work as the compile complains it doesn't find any module by that name from that perspective.
